/*****************************************************************************************
Name:  EmployeeGoogleRegistrationHandler()
============================================================================================================
Purpose:                                                            
-------    
This class provides logic for authorisation of Employees trying to sign in with Single Sign on. Pleas note 
that it is NOT a just-in-time provisioner. This is where JIT handling would occur, but at this stage, there is
a requirement that all employee users ALREADY exist in salesfforce, hence the removal of all JIT provisioning. 

It depends on values in the SSO_Openid_Provisioner_Settings__c custom setting to determine which domains it 
will allow in. 

Note that this class was auto-generated by Salesforce and then modified.                                                 
============================================================================================================
History                                                            
-------                                                            
VERSION   AUTHOR      DATE    DETAIL                Description
1.0       Garth James   14/11/2016  INITIAL DEVELOPMENT   Created 
********************************************************************************************/

global class EmployeeGoogleRegistrationHandler implements Auth.RegistrationHandler{
  class EmpException extends Exception{}

  static String ALLOWED_DOMAINS                 = 'EMPLOYEE_IDP_ALLOWED_DOMAINS_LIST';
  static String OPENID_UID_ATTRIBUTE_NAME       = 'EMPLOYEE_IDP_PARAMETER_UID';
  static String OPENID_DOMAIN_ATTRIBUTE_NAME    = 'EMPLOYEE_IDP_PARAMETER_HOSTED_DOMAIN';
  static String SSO_CUSTOM_SETTING_OBJECT_NAME  = 'OpenID SSO Settings';
  

  /*******************************************************************
  Purpose:  This method returns a custom setting with the parameters required for the provision
            If it is unable to find the parameters, it will throw an error
                                                     
  Parameters: customSettingRecordName   The name of the custom setting to look up

  Returns: employeeCustomSetting
  Throws [Exceptions]:  OpenID_SSO_CustomSettingNotDefined
  ********************************************************************/ 
  global Map<String, String> getEmployeeOpenIdCustomSettings() {

    Map<String, Openid_SSO_Settings__c> employeeOpenIdSettingsMap = Openid_SSO_Settings__c.getAll();
    Map<String, String>                 employeeOpenIdStringMap   = new Map<String, String>();

    if (employeeOpenIdSettingsMap.isEmpty()) {
      throw new EmpException(String.format(Label.OpenID_SSO_CustomSettingNotDefined, new List<String> {SSO_CUSTOM_SETTING_OBJECT_NAME}));
    }

    // Hosted Domain parameter shouldn't be blank - better to throw an error than to allow anyone in (one could logically deduce that if
    // the Hosted Domain is blank that it means anyone from any domain can log in. In this case, we are expressly STOPPING 
    // that from happening. 
    // Note this approach will then STOP all Google single sign on if the Hosted Domain is blank    
    if (employeeOpenIdSettingsMap.get(ALLOWED_DOMAINS)==null) {
      throw new EmpException(String.format(Label.OpenID_SSO_CustomSettingNotDefined, new List<String> {SSO_CUSTOM_SETTING_OBJECT_NAME + ': ' + ALLOWED_DOMAINS}));      
    }

    // make sure there is a mapping for the domain - we can't proceed without one
    if (employeeOpenIdSettingsMap.get(OPENID_DOMAIN_ATTRIBUTE_NAME)==null) {
      throw new EmpException(String.format(Label.OpenID_SSO_CustomSettingNotDefined, new List<String> {SSO_CUSTOM_SETTING_OBJECT_NAME + ': ' + OPENID_DOMAIN_ATTRIBUTE_NAME}));      
    }    

    for (Openid_SSO_Settings__c settingsRow: employeeOpenIdSettingsMap.values()) {
      employeeOpenIdStringMap.put(settingsRow.Name, settingsRow.Value__c);
    }

    return employeeOpenIdStringMap;
  }




  /*******************************************************************
  Purpose:  This method checks the list of domains to determine if this user's session carries an 
            authorised domain. 
                                                     
  Parameters: data                    System supplied OOTB Salesforce class which contains the attributes of the OpenID Call

  Returns: isTrustedDomain
  Throws [Exceptions]:  None
  ********************************************************************/ 
  global boolean canLogin(Auth.UserData requestData, Map<String, String> employeeOpenIdSettingsMap) {

/*  // Useful little loop to see what's in the Auth.UserData object
    System.debug('userData: ' + requestData);

    for (String attributeKey : requestData.attributeMap.keySet()) {
      System.debug('attribute: ' + attributeKey + ' = ' + requestData.attributeMap.get(attributeKey));
    }
*/

    String        hostedDomains         = employeeOpenIdSettingsMap.get(ALLOWED_DOMAINS);
                  hostedDomains         = hostedDomains.deleteWhitespace();
    List<String>  listOfAllowedDomains  = hostedDomains.split(';');
    Set<String>   setOfAllowedDomains   = new Set<String>(listOfAllowedDomains); // convert to set to use the .contains method

    Boolean isTrustedDomain = false;

    String domainAttributeName = employeeOpenIdSettingsMap.get(OPENID_DOMAIN_ATTRIBUTE_NAME);

    if(requestData.attributeMap.containsKey(domainAttributeName)) {
    	if(setOfAllowedDomains.contains(requestData.attributeMap.get(domainAttributeName))) {
    		isTrustedDomain = true;
    	} 
    }

    return isTrustedDomain;
  }


  /*******************************************************************
  Purpose:  This is a system generated method (method signature & parameters unchanged). 

            As I understand it, this method is called when the first SSO request for a user's session occurs (i.e. the first time the log on for the day
            or session - not just the first time they log in ever)
            Thereafter, all subsequent SSO calls for that user (provided he is still logged in) will call the updateUser method.
                                                     
  Parameters: portalId                System supplied Id for a Portal (not available to CCS as deprecated functionality). Expecting this to always be null.
              data                    System supplied OOTB Salesforce class which contains the attributes of the OpenID Call

  Returns: User object
  Throws [Exceptions]:  Employee_SSO_DomainNotAuthorised
                        Employee_SSO_UserNotFound
  ********************************************************************/ 
  global User createUser(Id portalId, Auth.UserData requestData){

    Map<String, String> employeeOpenIdSettingsMap = getEmployeeOpenIdCustomSettings();

  	if(!canLogin(requestData, employeeOpenIdSettingsMap)) {
  		//Returning null or throwing an exception fails the SSO flow
  		throw new EmpException(String.format(Label.Employee_SSO_DomainNotAuthorised, new List<String> {String.valueOf(requestData.email)}));
  	}
    
    List<User> listOfUsers = [SELECT Id FROM User WHERE federationIdentifier = :requestData.email AND isActive = true];
    if(listOfUsers.isEmpty()) {
      throw new EmpException(String.format(Label.Employee_SSO_UserNotFound, new List<String> {String.valueOf(requestData.email)}));
    } else {
      return listOfUsers.get(0); // FederationIdentifier is unique, so only one record should be returned
    }
  }


  /*******************************************************************
  Purpose:  This is a system generated method (method signature & parameters unchanged). 

            As I understand it, this method is called for all subsequent SSO calls after the initial login request.
                                                     
  Parameters: userId                  System supplied Id that presumably comes from the existing signon session
              portalId                System supplied Id for a Portal (not available to CCS as deprecated functionality). Expecting this to always be null.
              data                    System supplied OOTB Salesforce class which contains the attributes of the OpenID Call

  Returns: Nothing (void)
  Throws [Exceptions]:  Generic Exception if update fails
  ********************************************************************/ 
  global void updateUser(Id userId, Id portalId, Auth.UserData requestData){

    Map<String, String> employeeOpenIdSettingsMap = getEmployeeOpenIdCustomSettings();    

    if(!canLogin(requestData, employeeOpenIdSettingsMap)) {
      throw new EmpException(String.format(Label.Employee_SSO_DomainNotAuthorised, new List<String> {String.valueOf(requestData.email)}));
    }

  	User u                   = new User(id=userId);

    if(requestData.attributeMap.containsKey(employeeOpenIdSettingsMap.get(OPENID_UID_ATTRIBUTE_NAME))) {
      u.User_External_Id__c  = requestData.attributeMap.get(employeeOpenIdSettingsMap.get(OPENID_UID_ATTRIBUTE_NAME));
    }
    
  	u.lastName               = requestData.lastName;
  	u.firstName              = requestData.firstName;

    try {
  	 update(u);
    } catch(Exception e) {
      throw new EmpException(String.valueOf(e.getMessage()));
    }

  }
}